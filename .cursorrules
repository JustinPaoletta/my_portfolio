# Cursor AI Rules for My Portfolio Project

## Core Principles
- Always prioritize accessibility (a11y) and type safety
- Write clean, maintainable, and well-documented code
- Follow existing project patterns and conventions
- Ensure all code passes ESLint and TypeScript checks before suggesting commits

## Accessibility (a11y) Standards

### Interactive Elements
- **Mouse events MUST have keyboard equivalents:**
  - `onMouseOver` → requires `onFocus`
  - `onMouseOut` → requires `onBlur`
  - `onMouseEnter` → requires `onFocus`
  - `onMouseLeave` → requires `onBlur`
- **All interactive elements must be keyboard accessible:**
  - Use semantic HTML (`<button>`, `<a>`, etc.) instead of `<div>` with click handlers
  - If using non-semantic elements, add `role` and `tabIndex` attributes
- **Images must have alt text:**
  - Descriptive `alt` for meaningful images
  - Empty `alt=""` for decorative images
- **Forms must be accessible:**
  - Always associate labels with inputs using `htmlFor`
  - Provide clear error messages with `aria-describedby`
  - Use `aria-invalid` for invalid fields
- **Color and contrast:**
  - Never rely on color alone to convey information
  - Ensure sufficient contrast ratios (WCAG AA minimum)
- **ARIA attributes:**
  - Use `aria-label` for icon buttons without visible text
  - Use `role="alert"` for important messages
  - Use `aria-live` for dynamic content updates

### Examples
```tsx
// ❌ BAD - Missing keyboard handlers
<button onMouseOver={handleHover}>Hover me</button>

// ✅ GOOD - Has both mouse and keyboard handlers
<button
  onMouseOver={handleHover}
  onFocus={handleHover}
  onMouseOut={handleLeave}
  onBlur={handleLeave}
>
  Hover me
</button>

// ❌ BAD - Div with click handler
<div onClick={handleClick}>Click me</div>

// ✅ GOOD - Semantic button element
<button onClick={handleClick}>Click me</button>
```

## TypeScript Type Safety Standards

### Never Use `any`
- **NEVER use `any` type** - use proper types or `unknown` instead
- If dealing with third-party libraries without types, create proper type definitions
- Use type assertions with proper types: `as TypeName` instead of `as any`

### Type Definitions
- **Always define explicit types for:**
  - Function parameters
  - Function return types
  - Component props interfaces
  - State variables (when not obvious from initial value)
  - API responses
  - Event handlers
- **Use `unknown` instead of `any`** when type is truly uncertain
- **Use union types** for variables that can have multiple specific types
- **Use generics** for reusable type-safe functions/components

### Examples
```tsx
// ❌ BAD - Using any
const data = (window as any).myProperty;
function handleEvent(event: any) { }

// ✅ GOOD - Proper types
const data = (window as Window & { myProperty?: string }).myProperty;
function handleEvent(event: React.MouseEvent<HTMLButtonElement>) { }

// ❌ BAD - Missing return type
function calculate(x: number, y: number) {
  return x + y;
}

// ✅ GOOD - Explicit return type
function calculate(x: number, y: number): number {
  return x + y;
}

// ❌ BAD - Implicit any in catch
try {
  // code
} catch (error) {
  console.log(error.message);
}

// ✅ GOOD - Proper error typing
try {
  // code
} catch (error) {
  if (error instanceof Error) {
    console.log(error.message);
  }
}
```

## React Standards

### Component Naming
- **All exported components MUST have explicit names**
- Never use anonymous default exports with HOCs
- Name components with PascalCase

### Examples
```tsx
// ❌ BAD - Anonymous component with HOC
export default withSomething(() => <div>Content</div>);

// ✅ GOOD - Named component
const MyComponent = () => <div>Content</div>;
export default withSomething(MyComponent);

// ✅ ALSO GOOD - Named constant
const EnhancedComponent = withSomething(MyComponent);
export default EnhancedComponent;
```

### Hooks
- Follow Rules of Hooks (only call at top level)
- Always include dependency arrays for `useEffect`, `useCallback`, `useMemo`
- Name custom hooks with `use` prefix

### State Management
- Use proper TypeScript types for `useState`
- Prefer `useReducer` for complex state logic
- Keep state as local as possible

## Error Handling

### Always Handle Errors
- Wrap risky operations in try-catch blocks
- Type errors properly (avoid `any` in catch blocks)
- Log errors appropriately (use Sentry in production)
- Provide user-friendly error messages

### Examples
```tsx
// ✅ GOOD - Proper error handling
async function fetchData(): Promise<Data> {
  try {
    const response = await fetch('/api/data');
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return await response.json();
  } catch (error) {
    if (error instanceof Error) {
      console.error('Failed to fetch data:', error.message);
      Sentry.captureException(error);
    }
    throw error;
  }
}
```

## Performance

### Optimization
- Use `React.memo` for expensive components
- Use `useCallback` for functions passed as props
- Use `useMemo` for expensive calculations
- Lazy load components and routes when appropriate
- Optimize images (use WebP, proper sizing)

## Environment Variables

### Validation
- Always validate environment variables using the `validateEnv()` function
- Use TypeScript to define expected env var types
- Never access `import.meta.env` directly in components - use `src/config/env.ts`
- Provide sensible defaults for optional variables

## Code Organization

### File Structure
- One component per file
- Co-locate related files (component + styles + tests)
- Use index files for clean imports
- Keep utility functions in `src/utils/`
- Keep hooks in `src/hooks/`

### Imports
- Group imports: React, third-party, local
- Use absolute imports when available
- Avoid circular dependencies

### Comments
- Write JSDoc comments for exported functions/components
- Explain "why" not "what" in inline comments
- Keep comments up-to-date with code changes

## Testing (when applicable)

### Write Tests For
- Utility functions
- Custom hooks
- Critical user flows
- Complex business logic

### Test Standards
- Use meaningful test descriptions
- Test behavior, not implementation
- Include accessibility checks in tests

## Git Commit Standards

### Before Committing
- Ensure no ESLint errors
- Ensure no TypeScript errors
- Run `npm run lint` to verify
- Run `npm run type-check` to verify
- Follow conventional commit format

### Commit Messages
- Use conventional commits: `feat:`, `fix:`, `docs:`, etc.
- Keep first line under 72 characters
- Provide context in commit body when needed

## Security

### Best Practices
- Never commit secrets or API keys
- Validate all user inputs
- Sanitize data before rendering
- Use environment variables for configuration
- Keep dependencies updated

## Documentation

### When to Document
- Update README.md when adding new features
- Document complex algorithms or business logic
- Keep CHANGELOG.md updated
- Add JSDoc comments for public APIs
- Update relevant docs in `/docs` folder

## Analytics & Monitoring

### Privacy-First
- Use Umami for privacy-friendly analytics
- Never track PII without explicit consent
- Use Sentry for error monitoring
- Set appropriate sample rates for production

## PWA Considerations

### Offline Support
- Ensure critical functionality works offline
- Provide clear offline indicators
- Handle network errors gracefully
- Test service worker behavior

## Summary Checklist

Before suggesting any code changes, verify:
- ✅ No TypeScript `any` types used
- ✅ All mouse events have keyboard equivalents
- ✅ All interactive elements are accessible
- ✅ Components have explicit names
- ✅ Error handling is properly typed
- ✅ Code follows existing project patterns
- ✅ No ESLint or TypeScript errors
- ✅ Appropriate comments and documentation
- ✅ Environment variables properly validated
- ✅ Sensitive data not exposed

